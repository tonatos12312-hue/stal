import re
from argparse import ArgumentParser
from pathlib import Path
from typing import List, Tuple, Dict

class ResourceGenerator:
    def __init__(self):
        self.supported_image_extensions = { '.png', '.jpg', '.jpeg', '.bmp', '.webp', '.ico' }
        self.supported_font_extensions = { '.ttf', '.otf' }

    def normalize_name(self, filename: str) -> str:
        name = Path(filename).stem
        name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        if name[0].isdigit():
            name = f'_{name}'

        return name.lower()

    def format_bytes_array(self, bytes_data: List[int], indent: int = 12) -> str:
        lines = []
        line_length = 0
        current_line = []

        for i, byte in enumerate(bytes_data):
            byte_str = f'0x{byte:02x}'
            if i < len(bytes_data) - 1:
                byte_str += ","

            if line_length + len(byte_str) + 1 > 100:
                lines.append(' ' * indent + ''.join(current_line))
                current_line = [byte_str + ' ']
                line_length = len(byte_str) + 1
            else:
                current_line.append(byte_str + ' ')
                line_length += len(byte_str) + 1

        if current_line:
            lines.append(' ' * indent + ''.join(current_line).rstrip())

        return '\n'.join(lines)

    def read_file_as_bytes(self, file_path: Path) -> List[int]:
        with open(file_path, 'rb') as f:
            return list(f.read())

    def process_directory(self, resource_dir: Path) -> Tuple[List[Dict], List[Dict]]:
        images = []
        fonts = []

        for file_path in resource_dir.rglob('*'):
            if file_path.is_file():
                extension = file_path.suffix.lower()

                if extension in self.supported_image_extensions:
                    relative_path = file_path.relative_to(resource_dir)
                    var_name = self.normalize_name(str(relative_path).replace('/', '_').replace('\\', '_'))
                    bytes_data = self.read_file_as_bytes(file_path)

                    images.append({
                        'name': var_name,
                        'path': str(relative_path),
                        'bytes': bytes_data,
                        'size': len(bytes_data)
                    })

                elif extension in self.supported_font_extensions:
                    relative_path = file_path.relative_to(resource_dir)
                    var_name = self.normalize_name(str(relative_path).replace('/', '_').replace('\\', '_'))
                    bytes_data = self.read_file_as_bytes(file_path)

                    fonts.append({
                        'name': var_name,
                        'path': str(relative_path),
                        'bytes': bytes_data,
                        'size': len(bytes_data)
                    })

        return images, fonts

    def generate_header(self, images: List[Dict], fonts: List[Dict], namespace: str = "generated", font_sizes: List[float] = [16.0]) -> str:
        header = f"""// WARNING! All changes made in this file will be lost!
// This file is auto generated by using resource_generator.py

#pragma once

#include <common/resource/resource_manager.h>
#include <vector>
#include <cstdint>

namespace {namespace} {{
"""

        for img in images:
            header += f"\n    extern common::image* {img['name']};\n"

        for font in fonts:
            for size in font_sizes:
                size_str = str(int(size)) if size == int(size) else str(size)
                header += f"\n    extern common::font* {font['name']}_{size_str};\n"

        header += f"\n    void setup_resources(common::resource_manager* resource_manager);\n\n"
        header += f"}}\n"

        return header

    def generate_source(self, images: List[Dict], fonts: List[Dict], namespace: str = "generated", font_sizes: List[float] = [16.0]) -> str:
        source = f"""// WARNING! All changes made in this file will be lost!
// This file is auto generated by using resource_generator.py

#include "resources.h"

namespace {namespace} {{
"""

        for img in images:
            source += f"\n    common::image* {img['name']} = nullptr;\n"

        for font in fonts:
            for size in font_sizes:
                size_str = str(int(size)) if size == int(size) else str(size)
                source += f"\n    common::font* {font['name']}_{size_str} = nullptr;\n"

        source += f"\n    void setup_resources(common::resource_manager* resource_manager) {{\n"

        for img in images:
            source += f"\n        {{\n"
            source += f"            const std::vector<uint8_t> data = {{\n"
            source += self.format_bytes_array(img['bytes'])
            source += f"\n            }};\n"
            source += f"            {img['name']} = resource_manager->create_image_from_bytes(data);\n"
            source += f"        }}\n"

        for font in fonts:
            for size in font_sizes:
                size_str = str(int(size)) if size == int(size) else str(size)
                source += f"\n        {{\n"
                source += f"            const std::vector<uint8_t> data = {{\n"
                source += self.format_bytes_array(font['bytes'])
                source += f"\n            }};\n"
                source += f"            {font['name']}_{size_str} = resource_manager->create_font_from_bytes(data, {size}f);\n"
                source += f"        }}\n"

        source += f"    }}\n"

        source += f"}}\n"

        return source

    def generate(self, project_dir: Path, output_dir: Path = None, namespace: str = 'generated', font_sizes=None):
        if font_sizes is None:
            font_sizes = [ 16.0 ]

        resource_dir = project_dir / 'resource'

        if not resource_dir.exists():
            print(f'Resource directory not found: {resource_dir}')
            return False

        if output_dir is None:
            output_dir = project_dir / 'generated'

        output_dir.mkdir(exist_ok=True)

        images, fonts = self.process_directory(resource_dir)

        print(f'Found {len(images)} images and {len(fonts)} fonts')

        header_content = self.generate_header(images, fonts, namespace, font_sizes)
        source_content = self.generate_source(images, fonts, namespace, font_sizes)

        header_file = output_dir / 'resources.h'
        source_file = output_dir / 'resources.cpp'

        with open(header_file, 'w') as f:
            f.write(header_content)

        with open(source_file, 'w') as f:
            f.write(source_content)

        print(f'Generated:')
        print(f'  {header_file}')
        print(f'  {source_file}')

        return True

def main():
    parser = ArgumentParser(description='Generate header file for project resources')
    parser.add_argument('project_dir', type=Path, help='Path to project directory')
    parser.add_argument('--output', '-o', type=Path, help='Output directory')
    parser.add_argument('--namespace', '-n', default='generated', help='C++ namespace name (default: generated)')
    parser.add_argument('--font-sizes', '-s', nargs='+', type=float, default=[16.0], help='Font sizes to generate (default: 16.0)')

    args = parser.parse_args()
    if not args.project_dir.exists():
        print('Project directory not exists')
        return

    generator = ResourceGenerator()
    if generator.generate(args.project_dir, args.output, args.namespace, args.font_sizes):
        print('Done')

if __name__ == '__main__':
    main()
